"""
Django models related to the Tasking system
"""

import logging
import traceback
from datetime import timedelta
from gettext import gettext as _

from django.conf import settings
from django.contrib.postgres.fields import ArrayField, HStoreField
from django.contrib.postgres.indexes import GinIndex
from django.core.serializers.json import DjangoJSONEncoder
from django.db import connection, models
from django.utils import timezone
from django_lifecycle import hook, AFTER_CREATE

from pulpcore.app.models import (
    AutoAddObjPermsMixin,
    BaseModel,
    GenericRelationModel,
)
from pulpcore.app.models.status import BaseAppStatus
from pulpcore.app.models.fields import EncryptedJSONField
from pulpcore.constants import TASK_CHOICES, TASK_INCOMPLETE_STATES, TASK_STATES
from pulpcore.exceptions import AdvisoryLockError, exception_to_dict
from pulpcore.app.util import get_domain_pk, current_task
from pulpcore.app.loggers import deprecation_logger

_logger = logging.getLogger(__name__)


class Worker(BaseAppStatus):
    """
    Represents a worker
    Deprecated, to be removed with 3.87.
    """

    APP_TTL = timedelta(seconds=settings.WORKER_TTL)

    @property
    def current_task(self):
        """
        The task this worker is currently executing, if any.

        Returns:
            Task: The currently executing task
        """
        return self.tasks.filter(state="running").first()


def _uuid_to_advisory_lock(value):
    return ((value >> 64) ^ value) & 0x7FFFFFFFFFFFFFFF


class ProfileArtifact(BaseModel):
    """
    A model encapsulating profiled artifact data
    """

    artifact = models.ForeignKey("Artifact", on_delete=models.CASCADE)
    task = models.ForeignKey("Task", on_delete=models.CASCADE)
    name = models.TextField()

    class Meta:
        unique_together = ("task", "name")


class TaskManager(models.Manager):
    def get_queryset(self):
        # Always make encrypted args deferred.
        # This will prevent a lot of issues when the fernet key is lost.
        # Only task workers need to be able to read these args anyway.
        return super().get_queryset().defer("enc_args", "enc_kwargs")


class Task(BaseModel, AutoAddObjPermsMixin):
    """
    Represents a task

    The Tasks state machine works like a finite automaton without loops:
    The initial state is WAITING.
    Final states are COMPLETED, FAILED and CANCELED.
    The possible transitions are:
        WAITING -> RUNNING
        WAITING ->* CANCELING
        RUNNING -> COMPLETED
        RUNNING -> FAILED
        RUNNING ->* CANCELING
        CANCELING -> CANCELED

    The transitions to CANCELING (marked with *) are the only ones allowed to happen without
    holding the tasks advisory lock. Canceling is meant to be initiated asyncronously by a sparate
    process before signalling the worker via Postgres LISTEN.

    Fields:

        state (models.TextField): The state of the task
        name (models.TextField): The name of the task
        logging_cid (models.TextField): The logging CID associated with the task
        unblocked_at (models.DateTimeField): The time the task was marked as unblocked.
            This is supervised/updated by all awake workers and is part of the definition
            of a ready-to-be-taken task.
        started_at (models.DateTimeField): The time the task started executing
        finished_at (models.DateTimeField): The time the task finished executing
        error (models.JSONField): Fatal errors generated by the task
        args (models.JSONField): The JSON serialized arguments for the task
        kwargs (models.JSONField): The JSON serialized keyword arguments for
            the task
        reserved_resources_record (django.contrib.postgres.fields.ArrayField): The reserved
            resources required for the task.
        immediate (models.BooleanField): Whether this is guaranteed to execute fast
            without blocking. Defaults to `False`.
        deferred (models.BooleanField): Whether to allow defer running the task to a
            pulpcore_worker. Both `immediate` and `deferred` cannot both be `False`.
            Defaults to `True`.

    Relations:

        parent (models.ForeignKey): Task that spawned this task (if any)
        worker (models.ForeignKey): The worker that this task is in
        pulp_domain (models.ForeignKey): The domain the Task is a part of
    """

    objects = TaskManager()

    state = models.TextField(choices=TASK_CHOICES)
    name = models.TextField()
    logging_cid = models.TextField(db_index=True)

    unblocked_at = models.DateTimeField(null=True)
    started_at = models.DateTimeField(null=True)
    finished_at = models.DateTimeField(null=True)

    error = models.JSONField(null=True)

    enc_args = EncryptedJSONField(null=True, encoder=DjangoJSONEncoder)
    enc_kwargs = EncryptedJSONField(null=True, encoder=DjangoJSONEncoder)

    worker = models.ForeignKey("Worker", null=True, related_name="tasks", on_delete=models.SET_NULL)

    parent_task = models.ForeignKey(
        "Task", null=True, related_name="child_tasks", on_delete=models.SET_NULL
    )
    task_group = models.ForeignKey(
        "TaskGroup", null=True, related_name="tasks", on_delete=models.SET_NULL
    )
    reserved_resources_record = ArrayField(models.TextField(), null=True)
    pulp_domain = models.ForeignKey("Domain", default=get_domain_pk, on_delete=models.CASCADE)
    versions = HStoreField(default=dict)

    profile_options = ArrayField(models.TextField(), null=True)
    profile_artifacts = models.ManyToManyField("Artifact", through=ProfileArtifact)

    immediate = models.BooleanField(default=False, null=True)
    deferred = models.BooleanField(default=True, null=True)

    def __str__(self):
        return "Task: {name} [{state}]".format(name=self.name, state=self.state)

    def __enter__(self):
        self.lock = _uuid_to_advisory_lock(self.pk.int)
        with connection.cursor() as cursor:
            cursor.execute("SELECT pg_try_advisory_lock(%s)", [self.lock])
            acquired = cursor.fetchone()[0]
        if not acquired:
            raise AdvisoryLockError("Could not acquire lock.")
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        with connection.cursor() as cursor:
            cursor.execute("SELECT pg_advisory_unlock(%s)", [self.lock])
            released = cursor.fetchone()[0]
        if not released:
            raise RuntimeError("Lock not held.")

    @staticmethod
    def current_id():
        """
        Returns:
            uuid.UUID: The current task id.
        """
        try:
            return current_task.get().pk
        except AttributeError:
            return None

    @staticmethod
    def current():
        """
        Returns:
            pulpcore.app.models.Task: The current task.
        """
        return current_task.get()

    @hook(AFTER_CREATE)
    def add_role_dispatcher(self):
        """Set the "core.task_user_dispatcher" role for the current user after creation."""
        self.add_roles_for_object_creator("core.task_user_dispatcher")

    def _cleanup_progress_reports(self, state):
        """Find any running progress-reports and set their states to the specified end-state."""
        self.progress_reports.filter(state=TASK_STATES.RUNNING).update(state=state)

    def set_running(self):
        """
        Set this Task to the running state, save it, and log output in warning cases.

        This updates the :attr:`started_at` and sets the :attr:`state` to :attr:`RUNNING`.
        """
        started_at = timezone.now()
        rows = Task.objects.filter(pk=self.pk, state=TASK_STATES.WAITING).update(
            state=TASK_STATES.RUNNING,
            started_at=started_at,
        )
        if rows == 1:
            self.state = TASK_STATES.RUNNING
            self.started_at = started_at
        else:
            self.refresh_from_db()
            raise RuntimeError(
                _("Attempt to set not waiting task {} to running from '{}'.").format(
                    self.pk, self.state
                )
            )

    def set_completed(self):
        """
        Set this Task to the completed state, save it, and log output in warning cases.

        This updates the :attr:`finished_at` and sets the :attr:`state` to :attr:`COMPLETED`.
        """
        # Only set the state to finished if it's running. This is important for when the task has
        # been canceled, so we don't move the task from canceled to finished.
        finished_at = timezone.now()
        rows = Task.objects.filter(pk=self.pk, state=TASK_STATES.RUNNING).update(
            state=TASK_STATES.COMPLETED,
            finished_at=finished_at,
        )
        if rows == 1:
            self.state = TASK_STATES.COMPLETED
            self.finished_at = finished_at
        else:
            self.refresh_from_db()
            # If the user requested to cancel this task while the worker finished it, we leave it
            # as it is, but accept this is not an error condition.
            if self.state != TASK_STATES.CANCELING:
                raise RuntimeError(
                    _("Attempt to set not running task {} to completed from '{}'.").format(
                        self.pk, self.state
                    )
                )
        self._cleanup_progress_reports(TASK_STATES.COMPLETED)

    def set_failed(self, exc, tb):
        """
        Set this Task to the failed state and save it.

        This updates the :attr:`finished_at` attribute, sets the :attr:`state` to
        :attr:`FAILED`, and sets the :attr:`error` attribute.

        Args:
            exc (Exception): The exception raised by the task.
            tb (traceback): Traceback instance for the current exception.
        """
        finished_at = timezone.now()
        tb_str = "".join(traceback.format_tb(tb))
        error = exception_to_dict(exc, tb_str)
        rows = Task.objects.filter(pk=self.pk, state=TASK_STATES.RUNNING).update(
            state=TASK_STATES.FAILED,
            finished_at=finished_at,
            error=error,
        )
        if rows == 1:
            self.state = TASK_STATES.FAILED
            self.finished_at = finished_at
            self.error = error
        else:
            self.refresh_from_db()
            raise RuntimeError(
                _("Attempt to set not running task {} to failed from '{}'.").format(
                    self.pk, self.state
                )
            )
        self._cleanup_progress_reports(TASK_STATES.FAILED)

    def set_canceling(self):
        """
        Set this task to canceling from either waiting, running or canceling.

        This is the only valid transition without holding the task lock.
        """
        rows = Task.objects.filter(pk=self.pk, state__in=TASK_INCOMPLETE_STATES).update(
            state=TASK_STATES.CANCELING,
        )
        if rows == 1:
            self.state = TASK_STATES.CANCELING
        else:
            self.refresh_from_db()
            raise RuntimeError(
                _("Attempt to set not incomplete task {} to canceling from '{}'.").format(
                    self.pk, self.state
                )
            )

    def set_canceled(self, final_state=TASK_STATES.CANCELED, reason=None):
        """
        Set this task to canceled or failed from canceling.
        """
        # Make sure this function was called with a proper final state
        assert final_state in [TASK_STATES.CANCELED, TASK_STATES.FAILED]
        finished_at = timezone.now()
        task_data = {}
        if reason:
            task_data["error"] = {"reason": reason}
        rows = Task.objects.filter(pk=self.pk, state=TASK_STATES.CANCELING).update(
            state=final_state,
            finished_at=finished_at,
            **task_data,
        )
        if rows == 1:
            self.state = final_state
            self.finished_at = finished_at
            if reason:
                self.error = task_data["error"]
        else:
            self.refresh_from_db()
            raise RuntimeError(
                _("Attempt to set not canceling task {} to canceled from '{}'.").format(
                    self.pk, self.state
                )
            )
        self._cleanup_progress_reports(final_state)

    def unblock(self):
        # This should be safe to be called without holding the lock.
        unblocked_at = timezone.now()
        rows = Task.objects.filter(pk=self.pk).update(unblocked_at=unblocked_at)
        if rows == 1:
            self.unblocked_at = unblocked_at
        else:
            self.refresh_from_db()
            raise RuntimeError(
                _("Falied to set task {} unblocked in state '{}'.").format(self.pk, self.state)
            )

    class Meta:
        indexes = [
            models.Index(fields=["pulp_created"]),
            models.Index(fields=["unblocked_at"]),
            models.Index(fields=["state"]),
            models.Index(fields=["state", "pulp_created"]),
            GinIndex(
                name="pulp_task_resources_index",
                fields=["reserved_resources_record"],
                condition=~models.Q(state__in=["completed", "failed", "canceled", "skipped"]),
                opclasses=["array_ops"],
            ),
        ]
        permissions = [
            ("manage_roles_task", "Can manage role assignments on task"),
            ("view_task_profile_artifacts", "Can view profile data for task"),
        ]


class TaskGroup(BaseModel):
    description = models.TextField()
    all_tasks_dispatched = models.BooleanField(default=False)
    pulp_domain = models.ForeignKey("Domain", default=get_domain_pk, on_delete=models.CASCADE)

    @staticmethod
    def current():
        """
        Returns:
            pulpcore.app.models.TaskGroup: The task group the current task is being executed and
            belongs to.
        """
        try:
            task_group = Task.current().task_group
        except AttributeError:
            task_group = None
        return task_group

    def finish(self):
        """
        Finalize the task group.

        Set 'all_tasks_dispatched' to True so that API users can know that there are no
        tasks in the group yet to be created.
        """
        # "All tasks dispatched" cannot be relied on.
        deprecation_logger.warning(
            "TaskGroup finish is deprecated and scheduled for removal in Pulp 4."
        )
        self.all_tasks_dispatched = True
        self.save()


class CreatedResource(GenericRelationModel):
    """
    Resources created by the task.

    Relations:
        task (models.ForeignKey): The task that created the resource.
    """

    task = models.ForeignKey(
        Task, related_name="created_resources", default=Task.current, on_delete=models.CASCADE
    )


class TaskSchedule(BaseModel):
    name = models.TextField(unique=True, null=False)
    next_dispatch = models.DateTimeField(default=timezone.now, null=True)
    dispatch_interval = models.DurationField(null=True)
    task_name = models.TextField()
    last_task = models.ForeignKey(Task, null=True, on_delete=models.SET_NULL)

    class Meta:
        permissions = [
            ("manage_roles_taskschedule", "Can manage role assignments on task schedules"),
        ]
